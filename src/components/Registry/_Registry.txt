import { JSX, useEffect, useState } from 'react';

export interface ZComponentDefinition<TStore = Record<string, unknown>, TViewProps = unknown> {
  tag: string;
  store: TStore;
  view: React.ComponentType<TViewProps>;

  config?: {
    isObject?: boolean;
    autoInit?: boolean;
    defaultProps?: Partial<TViewProps>;
    detector?: (value: unknown) => boolean;
  };

  region?: {
    name: string;
    nodeView?: {
      name: string;
      icon?: React.ComponentType;
      getContent?: (node: unknown) => JSX.Element | null;
      fullContent?: (node: unknown) => JSX.Element | null;
    };
  };

  middleware?: {
    beforeRender?: (props: unknown) => void;
    afterRender?: (props: unknown) => void;
    cleanup?: () => void;
  };
}

export interface RegisteredComponent<TStore = () => any, TViewProps = unknown> {
  tag: string;
  store: TStore;
  view: React.ComponentType<TViewProps>;
  config?: ZComponentDefinition['config'];
  region?: ZComponentDefinition['region'];
  middleware?: ZComponentDefinition['middleware'];
}

export interface RegistryStats {
  totalComponents: number;
  totalStores: number;
  components: string[];
}

export class _Registry {
  private components = new Map<string, RegisteredComponent<any, any>>();
  private stores = new Map<string, () => any>();
  private regions: any[] = [];
  private objects: any[] = [];
  private areas = new Map<string, any[]>();
  private perRegionViews = new Map<string, Map<string, React.ComponentType>>();
  private tools = new Map<string, any>();

  private listeners = new Set<(event: RegistryEvent) => void>();

  registerComponent<TStore = () => any, TViewProps = unknown>(
    definition: ZComponentDefinition<TStore, TViewProps>,
  ): void {
    const normalizedTag = definition.tag.toLowerCase();

    if (this.components.has(normalizedTag)) {
      console.warn(`Component '${normalizedTag}' is already registered. Overwriting...`);
    }

    const registeredComponent: RegisteredComponent<TStore, TViewProps> = {
      tag: normalizedTag,
      store: definition.store,
      view: definition.view,
      config: definition.config,
      region: definition.region,
      middleware: definition.middleware as any,
    };

    this.components.set(normalizedTag, registeredComponent as RegisteredComponent<any, any>);

    this.stores.set(definition.store.name, definition.store);

    if (definition.config?.isObject) {
      this.objects.push(definition.store);
    }

    if (definition.region) {
      this.addRegionType(definition.region, definition.store.name, definition.config?.detector);
    }

    this.emit({
      type: 'component-registered',
      tag: normalizedTag,
      timestamp: Date.now(),
    });
  }

  registerComponents<T extends readonly ZComponentDefinition[]>(...definitions: T): void {
    for (const definition of definitions) {
      this.registerComponent(definition);
    }
  }

  unregisterComponent(tag: string): boolean {
    const normalizedTag = tag.toLowerCase();
    const removed = this.components.delete(normalizedTag);

    if (removed) {
      this.emit({
        type: 'component-unregistered',
        tag: normalizedTag,
        timestamp: Date.now(),
      });
    }

    return removed;
  }

  getComponent<TStore = () => any, TViewProps = unknown>(
    tag: string,
  ): RegisteredComponent<TStore, TViewProps> {
    const normalizedTag = tag.toLowerCase();
    const component = this.components.get(normalizedTag);

    // if (!component) {
    //   const available = Array.from(this.components.keys());
    //   throw new Error(
    //     `Component '${normalizedTag}' not registered.\nAvailable: ${available.join(', ') || 'none'}`,
    //   );
    // }

    return component as RegisteredComponent<TStore, TViewProps>;
  }

  getComponentView(tag: string): React.ComponentType {
    return this.getComponent(tag)?.view;
  }

  getComponentStore(tag: string): () => any {
    return this.getComponent(tag)?.store
  }

  hasComponent(tag: string): boolean {
    return this.components.has(tag.toLowerCase());
  }

  getAllComponents(): RegisteredComponent[] {
    return Array.from(this.components.values());
  }

  getComponentTags(): string[] {
    return Array.from(this.components.keys());
  }

  getStore(name: string): () => any {
    const store = this.stores.get(name);

    if (!store) {
      const available = Array.from(this.stores.keys());
      throw new Error(
        `Store '${name}' not registered.\nAvailable: ${available.join(', ') || 'none'}`,
      );
    }

    return store;
  }

  getAllStores(): Array<() => any> {
    return Array.from(this.stores.values());
  }

  private addRegionType(type: any, object: string, detector?: (value: unknown) => boolean): void {
    if (detector) {
      type.detectByValue = detector;
    }

    this.regions.push(type);

    const areas = this.areas.get(object);
    if (areas) {
      areas.push(type);
    } else {
      this.areas.set(object, [type]);
    }
  }

  getRegionTypes(): any[] {
    return [...this.regions];
  }

  getAvailableAreas(objectName: string, value?: unknown): any[] {
    const available = this.areas.get(objectName);

    if (!available) return [];

    if (value) {
      for (const model of available) {
        if (model.detectByValue && model.detectByValue(value)) {
          return [model];
        }
      }
    }

    return available.filter((a) => !a.detectByValue);
  }

  getObjectTypes(): any[] {
    return [...this.objects];
  }

  addPerRegionView(tag: string, mode: string, view: React.ComponentType): void {
    const normalizedTag = tag.toLowerCase();
    let tagViews = this.perRegionViews.get(normalizedTag);

    if (!tagViews) {
      tagViews = new Map();
      this.perRegionViews.set(normalizedTag, tagViews);
    }

    tagViews.set(mode, view);
  }

  getPerRegionView(tag: string, mode: string): React.ComponentType | undefined {
    const normalizedTag = tag.toLowerCase();
    return this.perRegionViews.get(normalizedTag)?.get(mode);
  }

  registerTool(name: string, model: any): void {
    this.tools.set(name, model);
    this.emit({
      type: 'tool-registered',
      name,
      timestamp: Date.now(),
    });
  }

  getTool(name: string): any {
    const tool = this.tools.get(name);

    if (!tool) {
      const available = Array.from(this.tools.keys());
      throw new Error(
        `Tool '${name}' not registered.\nAvailable: ${available.join(', ') || 'none'}`,
      );
    }

    return tool;
  }

  getAllTools(): Record<string, any> {
    const result: Record<string, any> = {};
    for (const [name, tool] of this.tools) {
      result[name] = tool;
    }
    return result;
  }

  getStats(): RegistryStats {
    return {
      totalComponents: this.components.size,
      totalStores: this.stores.size,
      components: this.getComponentTags(),
    };
  }

  clear(): void {
    this.components.clear();
    this.stores.clear();
    this.regions = [];
    this.objects = [];
    this.areas.clear();
    this.perRegionViews.clear();
    this.tools.clear();
    this.emit({
      type: 'registry-cleared',
      timestamp: Date.now(),
    });
  }

  export(): {
    components: Array<{
      tag: string;
      store: { name: string; description?: string; version?: string };
      config?: ZComponentDefinition['config'];
      region?: ZComponentDefinition['region'];
    }>;
    stats: RegistryStats;
  } {
    return {
      components: Array.from(this.components.values()).map((c) => ({
        tag: c.tag,
        store: { name: c.store.name, description: c.store.description, version: c.store.version },
        config: c.config,
        region: c.region,
      })),
      stats: this.getStats(),
    };
  }

  subscribe(listener: (event: RegistryEvent) => void): () => void {
    this.listeners.add(listener);
    return () => {
      this.listeners.delete(listener);
    };
  }

  private emit(event: RegistryEvent): void {
    for (const listener of this.listeners) {
      try {
        listener(event);
      } catch (error) {
        console.error('Error in registry listener:', error);
      }
    }
  }
}

export type RegistryEvent =
  | {
    type: 'component-registered';
    tag: string;
    timestamp: number;
  }
  | {
    type: 'component-unregistered';
    tag: string;
    timestamp: number;
  }
  | {
    type: 'tool-registered';
    name: string;
    timestamp: number;
  }
  | {
    type: 'registry-cleared';
    timestamp: number;
  };

export const Registry = new _Registry();

export function useZRegistry(): _Registry {
  const [, setTrigger] = useState({});

  useEffect(() => {
    const listener = () => setTrigger({});
    const unsubscribe = Registry.subscribe(() => {
      listener();
    });

    return () => {
      unsubscribe();
    };
  }, []);

  return Registry;
}

export function createRegistrationBatch<T extends readonly ZComponentDefinition[]>(
  ...definitions: T
): { register: () => void; components: T } {
  return {
    components: definitions,
    register: () => {
      Registry.registerComponents(...definitions);
    },
  };
}

export function defineZComponent<TStore = Record<string, unknown>, TViewProps = unknown>(
  config: ZComponentDefinition<TStore, TViewProps>,
): ZComponentDefinition<TStore, TViewProps> {
  return config;
}

export default Registry;
